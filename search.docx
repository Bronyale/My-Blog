查找
搜索引擎

速度：
	规模
	存储方式
		有序
		索引
		存储结构
		存储式
	存储位置

术语
	查找表
	关键字：数据元素中某个或某些数据的项的值，用以标识数据元素（或记录）
	查找
	查找的分类－－查找的环境
		静态查找：查找＋提取
		动态查找：查找＋插入或删除

查找的操作（k为关键字，F为查号表）：
	增insert(k, F)
	删delete(k, F)
	查search(k, F)

查找分类：
	基于关键字的查找
		线性查找
		折半查找（二分查找）
		分块查找
		二元树查找
	基于关键字存储位置的查找
		散列法

查找表节点：
	struct records{
		keyType key;
		fields other;
	}
查找的性能的指标－－平均查找长度ASL：进行比较次数的期望值

二叉查找树：
	根节点的关键字大于左子树上的关键字，小于右子树的关键字
	中序遍历得到递增序列
	同意数据集构成的二叉查找树不唯一，但中序序列相同
	每个节点X右子树的最左节点Y称为其继承节点：
		在次右子树中，其关键字最小，但大于X的关键字
		最多有一个右子树，即不存在左子树

AVL树
	平衡因子：左子树与右子数高度之差
	AVL树中任意节点的平衡因子的绝对值小于2
	AVL树是一种特殊的BST树，通过旋转来平衡树结构

B-树 B+树
	查询时磁盘I/O效率低下，为减少磁盘I/O次数，降低树的深度：
		每个节点存储多个数据
		采用多叉树
	m阶B树：
		所有节点中，孩子节点数的最大值称为B树的阶
		当一个节点有k - 1个孩子节点时，需要有k - 1个关键字将子树中的关键字划分为k个子集
		每个节点至少有两个孩子节点
		每个中间节点都包含k-1个元素和k个子孩子 m / 2 <= k <= m
		每一个叶节点包含k - 1个元素 m / 2 <= k <= m
		所有叶节点位于同一层
		每个节点的元素从小到大排列，其中k - 1个元素正好是其k个孩子节点元素的值的划分
		节点结构为：n, A0, A1...K1, K2, Kn
			n为节点个数 m / 2 <= n <= m - 1
			Ai为指向子树根节点的指针，Ai中所有节点的关键字小于ki + 1
			Ki为关键字，Ki < n + 1
	插入：
		if 节点中关键码个数 < m - 1
			直接插入
		if 节点中关键码个数 > m - 1
			节点分裂，以中间关键码为界将节点一分为二，产生新节点，并将中间关键码插入到父节点中
	删除：
		if 在非叶节点，且为key[i]
			从指针son[i]中找寻最小关键字代替key[i]
		if 若在叶节点：
			if 原关键字数n >= m / 2
				直接删除
			if 原关键字数n = m / 2 - 1
				if 相邻的兄弟节点中的关键字数n >= m / 2
					将右（左）中最小（大）移至双亲节点，将双亲节点中小于（大于）上移关键字的关键字下移至被删除的关键字所在的节点中
				if 相邻的兄弟节点中的关键字数n = m / 2 - 1
					删除之后，将该节点中生育关键字和指针加上双亲节点中的关键字ki一起合并到Ai所指的兄弟节点中去，若双亲节点中关键字数n = m / 2 - 1，则对其进行相同操作
	
					
					
